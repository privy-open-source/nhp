/* eslint-disable @typescript-eslint/no-empty-interface */
/**
 * ⚠️ DONT EDIT THIS FILE ⚠️
 * This generated by @privyid/nhp
 * If you want customize something, create new file with extension `.custom.ts`
 */
import {
  createLazyton,
  type ApiResponse,
  type AxiosRequestConfig,
} from '@privyid/nuapi/core'
import type { Merge } from 'type-fest'

export const useApi = createLazyton({ prefixURL: '/api/document' })

export interface FormDocumentsUploadShare {
  /**
   * Fill with document title
   */
  title: string,
  /**
   * Fill with document description
   */
  description: string,
  /**
   * Fill with category id (uuid)
   */
  category_id: string,
  /**
   * Fill with document workflow (default: SHARE_ONLY)
   */
  workflow: 'SHARE_ONLY' | 'SIGN_SHARE' | 'SIGN_SEAL_SHARE',
  /**
   * Fill with document participant action sequence
   */
  sequence: 'SERIAL' | 'PARALLEL' | 'COMBINED',
  /**
   * Fill with document file (pdf)
   */
  document: File,
  /**
   * Fill with document owner
   */
  owner: OwnerIdentifier,
  /**
   * Fill with document participants
   */
  participants: Participant[],
  /**
   * Fill with qr_code position
   */
  qr_code: QrCodeSpecification,
  /**
   * Fill with KEEP or REMOVE (if the document is already digitally signed)
   */
  overwrite: 'KEEP' | 'REMOVE',
  /**
   * Fill with document password (if the document is protected by password)
   */
  password: string,
}

export interface FormDocumentsMultipleUpload {
  documents: Array<{
    /**
     * Fill with pdf file
     */
    file: File,
    /**
     * Fill with document title
     */
    title: string,
    /**
     * Fill with category id (uuid)
     */
    category_id: string,
    /**
     * Fill with placement id (uuid)
     */
    placement_id: string,
    /**
     * Fill with document description
     */
    description: string,
    /**
     * Fill with PrivyID
     */
    owner: string,
    /**
     * Fill with overwrite mode
     */
    overwrite: 'KEEP' | 'REMOVE',
    /**
     * Fill with qr code specification
     */
    qr_code: QrCodeSpecification,
    /**
     * Fill with watermark specification
     */
    watermark: WatermarkSpecification,
  }>,
}

export interface FormDocuments {
  /**
   * Fill with document title
   */
  title: string,
  /**
   * Fill with document description
   */
  description: string,
  /**
   * Fill with category id (uuid)
   */
  category_id: string,
  /**
   * Fill with document participant action sequence
   */
  sequence: 'SERIAL' | 'PARALLEL' | 'COMBINED',
  /**
   * Fill with document file (pdf)
   */
  document: File,
  /**
   * Fill with document owner
   */
  owner: OwnerIdentifier,
  /**
   * Fill with qr_code position
   */
  qr_code: QrCodeSpecification,
  /**
   * Fill with KEEP or REMOVE (if the document is already digitally signed)
   */
  overwrite: 'KEEP' | 'REMOVE',
  /**
   * Fill with document password (if the document is protected by password)
   */
  password: string,
}

export interface Category {
  /**
   * id define category id.
   * - If category id is defined when uploading the document, it should return valid document category id.
   * - If category id is not defined, it will return uncategorized.
   * @example 'a1e74853-ae31-498b-93d3-42a4c5783041'
   */
  id: string,
  /**
   * name define category name.
   * - If category id is defined when uploading the document, it should return valid document category name.
   * - If category id is not defined, it will return Uncategorized.
   * @example 'Invoice'
   */
  name: string,
}

export interface InfoPresenter {
  metadata: Metadata,
  owner: Owner,
  participant: DocpresenterParticipant,
  security: Security,
  signature: Signature,
  status: Status,
}

export interface ListDocumentResponse {
  data: ListInfo[],
  meta: ListMeta,
}

export interface ListHistoryResponse {
  data: HistoryHistory[],
  meta: HistoryMeta,
}

export interface Metadata {
  /**
   * category holds document category information.
   */
  category: Category,
  /**
   * description holds the document description
   * @example 'Need your sign immediately :)'
   */
  description: string,
  /**
   * id holds the document id
   * @example '9ec552bb-fa31-4b06-ae17-98d0f0bd527e'
   */
  id: string,
  /**
   * title holds the document title
   * @example 'Project Contract'
   */
  title: string,
  /**
   * token holds the document token
   * @example 'dad8ac5ca9813b9d99d28b43bbf46602'
   */
  token: string,
  /**
   * uploaded_at holds the document uploading time
   * @example '2022-03-24T15:03:39+07:00'
   */
  uploaded_at: string,
  /**
   * url holds the document url, expires in 15 minutes
   * @example 'https://app.privy.id/document/9ec552bb-fa31-4b06-ae17-98d0f0bd527e'
   */
  url: string,
  /**
   * workflow holds the document workflow
   * * SELF_SIGN
   * * SELF_SEAL
   * * SELF_STAMP
   * * STAMP_SIGN
   * * SIGN_SEAL
   * * STAMP_SIGN_SEAL
   * * SHARE_ONLY
   * * SIGN_SHARE
   * * STAMP_SIGN_SHARE
   * * SIGN_SEAL_SHARE
   * * STAMP_SIGN_SEAL_SHARE
   * @example 'SHARE_ONLY'
   */
  workflow: string,
}

export interface Owner {
  /**
   * enterprise_id holds the enterprise id
   * @example '6e6b5743-5483-465c-9bc3-c21f40193579'
   */
  enterprise_id: string,
  /**
   * enterprise_name holds the name of enterprise
   * @example 'PT. Privy Identitas Digital'
   */
  enterprise_name: string,
  /**
   * position_id holds the position id related to owner position on behalf the enterprise
   *   // when the document is uploaded.
   * @example '44e8d835-7811-43ba-b45e-896cedf6b4dc'
   */
  position_id: string,
  /**
   * position_name holds the name of position related to owner position on behalf the enterprise
   * when the document is uploaded.
   * @example 'Backend Engineer'
   */
  position_name: string,
  /**
   * user_id holds the user id
   * @example '23022199-9c45-4332-8ea6-b587877916f0'
   */
  user_id: string,
  /**
   * user_id holds the user identifier
   * * privy_id - for registered user
   * * email - for un-registered user
   * * phone - for un-registered user
   * @example 'UAT001'
   */
  user_identifier: string,
  /**
   * user_name holds the name of user
   * @example 'John Doe'
   */
  user_name: string,
}

export interface OwnerIdentifier {
  /**
   * user_identifier define document owner identifier.
   * - If the owner is an existing user, use privyID.
   * - If the owner is not registered yet, use their email or phone.
   * @example 'UAT001'
   */
  user_identifier: string,
}

export interface Participant {
  /**
   * enterprise_identifier define enterprise association belongs to document participant.
   * - This field is optional, can be filled with enterprise ID or enterprise token.
   * - If the current field is filled with enterprise ID or enterprise token,
   *   our system will perform validation to ensure that document owner is associated to the
   *   selected enterprise.
   * - If the document participant already associated with the selected enterprise, this document
   *   marked as enterprise document (document ownership on behalf enterprise)
   * @example '91005c59-4ea4-4647-adde-98cac416615e'
   */
  enterprise_identifier: string,
  /**
   * one_of is a flag to determine that participant is in one of mode. OneOf required two or more
   * participant with same position on behalf enterprise.
   * @example true
   */
  one_of: boolean,
  /**
   * signature_placements define where the participant will sign the document inside the document.
   * It shows how many signature need to be placed by the participant.
   * - Signature placement can more than one per document.
   * - Maximum placement is twenty placements.
   */
  signature_placements: SignaturePlacement[],
  /**
   * signature_properties define custom signature header and description inside the signature field.
   */
  signature_properties: SignatureProperties,
  /**
   * type define role of participant.
   * - VIEWER
   * - REVIEWER
   * - APPROVER
   * - STAMPER
   * - SEALER
   * - SEALER
   * @example 'SIGNER'
   */
  type: string,
  /**
   * user_identifier define document participant identifier.
   * - If the participant is an existing user, use privyID.
   * - If the participant is not registered yet, use their email or phone.
   * @example 'UAT001'
   */
  user_identifier: string,
}

export interface QrCodeSpecification {
  /**
   * offset_x define the offset position based on the selected position.
   * @example 30
   */
  offset_x: number,
  /**
   * offset_y define the offset position based on the selected position.
   * @example 30
   */
  offset_y: number,
  /**
   * page_number define the document page for the qr code placement inside the document.
   * The default page is last page of the document.
   * * 1...n page for set the selected page.
   * * 0 for set the qr code in the last page.
   */
  page: number,
  /**
   * position define the placement of the qr code position inside the document.
   * * top-left
   * * top-right
   * * bottom-right
   * * bottom-left
   * @example 'bottom-right'
   */
  position: string,
}

export interface Role {
  /**
   * as represent the role of participant.
   * * VIEWER
   * * REVIEWER
   * * APPROVER
   * * STAMPER
   * * SIGNER
   * * SEALER
   * @example 'SIGNER'
   */
  as: string,
  /**
   * at represent the time of the action was taken by the current participant.
   * @example '2022-03-24T15:03:39+07:00'
   */
  at: string,
  /**
   * done represent state of the current participant already take an action based on his role or not yet.
   * @example true
   */
  done: boolean,
}

export interface Security {
  /**
   * encrypted represent the current document is encrypted.
   * @example true
   */
  encrypted: boolean,
  /**
   * encryption represent the current document encryption.
   * @example 'AES 256-bit'
   */
  encryption: string,
  /**
   * need_password represent the document will need password or not when take these action bellow:
   * * view
   * * approve
   * * stamp
   * * sign
   * * seal
   * @example true
   */
  need_password: boolean,
}

export interface ShareDocumentResponse {
  metadata: Metadata,
  owner: Owner,
  participant: DocpresenterParticipant,
  security: Security,
  status: Status,
}

export interface Signature {
  previous: SignatureInfo[],
}

export interface SignatureInfo {
  field: string,
  issuer: string,
  location: string,
  name: string,
  reason: string,
  signedAt: string,
  visible: boolean,
}

export interface SignaturePlacement {
  /**
   * draggable defines the participant can move pre-defined signature placement or not.
   * * true - fixed signature placement
   * * false - can adjust by moving the placement
   */
  draggable: boolean,
  /**
   * height defines the signature height.
   * @example 106
   */
  height: number,
  /**
   * page_number defines the position signature placement inside the document.
   * @example 1
   */
  page_number: number,
  /**
   * pos_x defines the signature placement x coordinates calculated from top-left of page.
   * @example 200
   */
  pos_x: number,
  /**
   * pos_y defines the signature placement y coordinates calculated from top-left of page.
   * @example 500
   */
  pos_y: number,
  /**
   * width defines the signature with.
   * @example 198
   */
  width: number,
}

export interface SignatureProperties {
  /**
   * description defines custom signature description on the signature field.
   * @example 'On behalf Carstensz Team'
   */
  description: string,
  /**
   * header defines custom signature header on the signature field.
   * @example 'Signed by UAT001'
   */
  header: string,
}

export interface State {
  /**
   * completed represent the current document is completed.
   * @example true
   */
  completed: boolean,
  /**
   * draft represent the current document is in draft state.
   */
  draft: boolean,
  /**
   * expired represent the current document is already expired.
   */
  expired: boolean,
  /**
   * in_progress represent the current document is in progress state.
   * @example true
   */
  in_progress: boolean,
  /**
   * rejected represent the current document has been rejected by one of participants.
   */
  rejected: boolean,
  /**
   * share represent the current document is already shared.
   * @example true
   */
  shared: boolean,
  /**
   * voided represent the current document is already voided before.
   */
  voided: boolean,
}

export interface Status {
  /**
   * description holds the document status description.
   * * draft
   * * in_progress
   * * rejected
   * * expired
   * * completed
   * * waiting your sign
   * * waiting {user_identifier} to {review/sign/approve/seal}
   * @example 'in progress'
   */
  description: string,
  state: State,
}

export interface StatusDocumentResponse {
  description: string,
  status: State,
}

export interface ThumbnailDocumentResponse {
  url: string,
}

export interface UploadDocumentResponse {
  metadata: Metadata,
  owner: Owner,
  participant: DocpresenterParticipant,
  security: Security,
  status: Status,
}

export interface UploadShareDocumentResponse {
  metadata: Metadata,
  owner: Owner,
  participant: DocpresenterParticipant,
  security: Security,
  status: Status,
}

export interface ViewDocumentResponse {
  metadata: Metadata,
  owner: Owner,
  participant: DocpresenterParticipant,
  security: Security,
  status: Status,
}

export interface VoidDocumentResponse {
  metadata: Metadata,
  owner: Owner,
  participant: DocpresenterParticipant,
  security: Security,
  status: Status,
}

export interface WatermarkSpecification {
  /**
   * @example 'Powered by PrivyID'
   */
  text_description: string,
  /**
   * @example 'This document was uploaded by Carstensz'
   */
  text_header: string,
}

export interface DocpresenterParticipant {
  /**
   * list holds the list of document participant.
   */
  list: DocpresenterParticipantData[],
  /**
   * sequence holds the rule for document participants to take an action to the document.
   * * PARALLEL - when the participant receive document, he can take an action (sign/approve/seal) immediately.
   * * SERIAL - when the participant receive document, he only can take an action when his turn is come based on the participants order.
   * * COMBINED - a grouped participants into PARALLEL group and SERIAL GROUP.
   * For an example, when the Document has three sequential groups:
   * group one is Serial:
   *   - UAT001 - Reviewer
   * group two is Parallel:
   *   - UAT002 - Signer
   *   - UAT003 - Signer
   *   - UAT004 - Signer
   * group one is Serial:
   *   - UAT005 - Sealer
   * So, the Document at the firstly, need to be reviewed by the UAT001. Then can be signed freely by UAT002, UAT003, and
   * UAT005 without waiting each other from the inside the group. Finally, it can be sealed by UAT005.
   * @example 'PARALLEL'
   */
  sequence: string,
}

export interface DocpresenterParticipantData {
  /**
   * enterprise_id holds the enterprise id
   * @example '6e6b5743-5483-465c-9bc3-c21f40193579'
   */
  enterprise_id: string,
  /**
   * enterprise_name holds the name of enterprise
   * @example 'PT. Privy Identitas Digital'
   */
  enterprise_name: string,
  /**
   * signature placeholder holds the participant signature placements.
   */
  placements: DocpresenterSignaturePlacement[],
  /**
   * position_id holds the position id related to owner position on behalf the enterprise
   *   // when the document is uploaded.
   * @example '44e8d835-7811-43ba-b45e-896cedf6b4dc'
   */
  position_id: string,
  /**
   * position_name holds the name of position related to owner position on behalf the enterprise
   * when the document is uploaded.
   * @example 'Backend Engineer'
   */
  position_name: string,
  /**
   * role holds the participant role related to the current document.
   */
  role: Role,
  /**
   * user_id holds the user id
   * @example '23022199-9c45-4332-8ea6-b587877916f0'
   */
  user_id: string,
  /**
   * user_id holds the user identifier
   * * privy_id - for registered user
   * * email - for un-registered user
   * * phone - for un-registered user
   * @example 'UAT001'
   */
  user_identifier: string,
  /**
   * user_name holds the name of user
   * @example 'John Doe'
   */
  user_name: string,
}

export interface DocpresenterSignaturePlacement {
  description: string,
  draggable: boolean,
  header: string,
  height: number,
  page_number: number,
  pos_x: number,
  pos_y: number,
  width: number,
}

export interface HistoryActor {
  enterprise_name: string,
  id: string,
  name: string,
  position_name: string,
  privy_id: string,
}

export interface HistoryHistory {
  activity: string,
  actor: HistoryActor,
  created_at: string,
  id: string,
  user_agent: string,
}

export interface HistoryMeta {
  page: number,
  per_page: number,
  total: number,
}

export interface ListInfo {
  metadata: Metadata,
  owner: Owner,
  participant: DocpresenterParticipant,
  security: Security,
  status: Status,
}

export interface ListMeta {
  page: number,
  per_page: number,
  total: number,
}

export interface ResponseErrorOutput {
  app_name: string,
  code: number,
  data: ResponseErrorOutputData[],
  error_code: string,
  message: string,
}

export interface ResponseErrorOutputData {
  description: string,
  field: string,
}

export interface ResponseSuccessOutput {
  /**
   * @example 200
   */
  code: number,
  data: any,
  /**
   * @example 'OK'
   */
  message: string,
  meta: any,
}

/**
 * Uses to list document
 */
export async function getDocuments (
  config?: AxiosRequestConfig,
): ApiResponse<Merge<ResponseSuccessOutput, { data: ListDocumentResponse }>> {
  return await useApi().get('/documents', config)
}

/**
 * Uses to upload document
 */
export async function postDocuments (
  body: FormDocuments,
  config?: AxiosRequestConfig,
): ApiResponse<Merge<ResponseSuccessOutput, { data: UploadDocumentResponse }>> {
  const form = new FormData()

  form.append('title', body.title)
  form.append('description', body.description)
  form.append('category_id', body.category_id)
  form.append('sequence', body.sequence)
  form.append('document', body.document)
  form.append('owner', JSON.stringify(body.owner))
  form.append('qr_code', JSON.stringify(body.qr_code))
  form.append('overwrite', body.overwrite)
  form.append('password', body.password)

  return await useApi().post('/documents', form, config)
}

/**
 * Uses to upload multiple document
 */
export async function postDocumentsMultipleUpload (
  body: FormDocumentsMultipleUpload,
  config?: AxiosRequestConfig,
): ApiResponse<Merge<ResponseSuccessOutput, { data: InfoPresenter[] }>> {
  const form = new FormData()

  for (let i = 0; i < body.documents.length; i++) {
    const item = body.documents[i]

    form.append(`documents[${i}][file]`, item.file)
    form.append(`documents[${i}][title]`, item.title)
    form.append(`documents[${i}][category_id]`, item.category_id)
    form.append(`documents[${i}][placement_id]`, item.placement_id)
    form.append(`documents[${i}][description]`, item.description)
    form.append(`documents[${i}][owner]`, item.owner)
    form.append(`documents[${i}][overwrite]`, item.overwrite)
    form.append(`documents[${i}][qr_code]`, JSON.stringify(item.qr_code))
    form.append(`documents[${i}][watermark]`, JSON.stringify(item.watermark))
  }

  return await useApi().post('/documents/multiple-upload', form, config)
}

/**
 * Uses to upload and share document
 */
export async function postDocumentsUploadShare (
  body: FormDocumentsUploadShare,
  config?: AxiosRequestConfig,
): ApiResponse<Merge<ResponseSuccessOutput, { data: UploadShareDocumentResponse }>> {
  const form = new FormData()

  form.append('title', body.title)
  form.append('description', body.description)
  form.append('category_id', body.category_id)
  form.append('workflow', body.workflow)
  form.append('sequence', body.sequence)
  form.append('document', body.document)
  form.append('owner', JSON.stringify(body.owner))
  form.append('participants', JSON.stringify(body.participants))
  form.append('qr_code', JSON.stringify(body.qr_code))
  form.append('overwrite', body.overwrite)
  form.append('password', body.password)

  return await useApi().post('/documents/upload-share', form, config)
}

/**
 * Uses to download document audit trail
 */
export async function getDocumentsIdDownloadAuditTrail (
  id: string,
  config?: AxiosRequestConfig,
): ApiResponse<globalThis.File> {
  return await useApi().get(`/documents/${id}/download/audit-trail`, config)
}

/**
 * Uses to download original document
 */
export async function getDocumentsIdDownloadOriginal (
  id: string,
  config?: AxiosRequestConfig,
): ApiResponse<globalThis.File> {
  return await useApi().get(`/documents/${id}/download/original`, config)
}

/**
 * Uses to download signed document
 */
export async function getDocumentsIdDownloadSigned (
  id: string,
  config?: AxiosRequestConfig,
): ApiResponse<globalThis.File> {
  return await useApi().get(`/documents/${id}/download/signed`, config)
}

/**
 * Uses to fetch document histories
 */
export async function getDocumentsIdHistories (
  id: string,
  config?: AxiosRequestConfig,
): ApiResponse<Merge<ResponseSuccessOutput, { data: ListHistoryResponse }>> {
  return await useApi().get(`/documents/${id}/histories`, config)
}

/**
 * Uses to get document permissions
 */
export async function getDocumentsIdPermissions (
  id: string,
  config?: AxiosRequestConfig,
): ApiResponse<Merge<ResponseSuccessOutput, { data: StatusDocumentResponse }>> {
  return await useApi().get(`/documents/${id}/permissions`, config)
}

/**
 * Uses to get document properties
 */
export async function getDocumentsIdProperties (
  id: string,
  config?: AxiosRequestConfig,
): ApiResponse<Merge<ResponseSuccessOutput, { data: StatusDocumentResponse }>> {
  return await useApi().get(`/documents/${id}/properties`, config)
}

/**
 * Uses to share document
 */
export async function putDocumentsIdShare (
  id: string,
  body: Participant[],
  config?: AxiosRequestConfig,
): ApiResponse<Merge<ResponseSuccessOutput, { data: ShareDocumentResponse }>> {
  return await useApi().put(`/documents/${id}/share`, body, config)
}

/**
 * Uses to get document status
 */
export async function getDocumentsIdStatus (
  id: string,
  config?: AxiosRequestConfig,
): ApiResponse<Merge<ResponseSuccessOutput, { data: StatusDocumentResponse }>> {
  return await useApi().get(`/documents/${id}/status`, config)
}

/**
 * Uses to get document thumbnail
 */
export async function getDocumentsIdThumbnail (
  id: string,
  config?: AxiosRequestConfig,
): ApiResponse<Merge<ResponseSuccessOutput, { data: ThumbnailDocumentResponse }>> {
  return await useApi().get(`/documents/${id}/thumbnail`, config)
}

/**
 * Uses to view document
 */
export async function getDocumentsIdView (
  id: string,
  config?: AxiosRequestConfig,
): ApiResponse<Merge<ResponseSuccessOutput, { data: ViewDocumentResponse }>> {
  return await useApi().get(`/documents/${id}/view`, config)
}

/**
 * Uses to void document
 */
export async function patchDocumentsIdVoid (
  id: string,
  config?: AxiosRequestConfig,
): ApiResponse<Merge<ResponseSuccessOutput, { data: VoidDocumentResponse }>> {
  return await useApi().patch(`/documents/${id}/void`, {}, config)
}
